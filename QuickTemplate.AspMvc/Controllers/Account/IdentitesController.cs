//@BaseCode
//MdStart
#if ACCOUNT_ON
namespace QuickTemplate.AspMvc.Controllers.Account
{
    using TAccessModel = Logic.Models.Account.Identity;
    using TViewModel = AspMvc.Models.Account.Identity;
    using TFilterModel = AspMvc.Models.Account.IdentityFilter;
    using TAccessContract = Logic.Contracts.Account.IIdentitiesAccess;
    
    using Microsoft.AspNetCore.Mvc;
    /// <summary>
    /// Represents a controller for managing identities.
    /// </summary>
    /// <typeparam name="TAccessModel">The type of the access model.</typeparam>
    /// <typeparam name="TViewModel">The type of the view model.</typeparam>
    /// <typeparam name="TFilterModel">The type of the filter model.</typeparam>
    /// <typeparam name="TAccessContract">The type of the access contract.</typeparam>
    public partial class IdentitiesController : Controllers.FilterGenericController<TAccessModel, TViewModel, TFilterModel, TAccessContract>
    {
        ///
        /// Generated by the generator
        ///
        static IdentitiesController()
        {
            ClassConstructing();
            ClassConstructed();
        }
        /// <summary>
        /// This method is called during the construction of the class.
        /// </summary>
        static partial void ClassConstructing();
        /// <summary>
        /// This method is called when the class is constructed.
        /// </summary>
        static partial void ClassConstructed();
        /// <summary>
        /// Gets the name of the controller.
        /// </summary>
        /// <remarks>
        /// This property returns the name of the controller as "Identities".
        /// </remarks>
        protected override string ControllerName => "Identities";
        ///
        /// Generated by the generator
        ///
        public IdentitiesController(TAccessContract other)
        : base(other)
        {
            Constructing();
            Constructed();
        }
        /// <summary>
        /// This method is called during the construction of an object.
        /// </summary>
        /// <remarks>
        /// This method is intended to be implemented by partial classes to
        /// perform additional construction logic.
        /// </remarks>
        /// <seealso cref="OtherConstructingMethod"/>
        /// <seealso cref="AnotherClass.Constructing"/>
        /// <seealso cref="SomeOtherClass.Constructing"/>
        partial void Constructing();
        /// <summary>
        /// Represents a partial method that is called when an object is constructed.
        /// </summary>
        /// <remarks>
        /// This partial method can be implemented in a partial class to perform any additional initialization or setup operations
        /// when an instance of the class is constructed.
        /// </remarks>
        /// <seealso cref="MyClass"/>
        partial void Constructed();
        ///
        /// Generated by the generator
        ///
        protected override TViewModel ToViewModel(TAccessModel accessModel, ActionMode actionMode)
        {
            var handled = false;
            var result = default(TViewModel);
            BeforeToViewModel(accessModel, actionMode, ref result, ref handled);
            if (handled == false || result == null)
            {
                result = TViewModel.Create(accessModel);
            }
            AfterToViewModel(result, actionMode);
            return BeforeView(result, actionMode);
        }
        /// <summary>
        /// This method is called before converting the access model to the view model.
        /// </summary>
        /// <param name="accessModel">The access model to be converted.</param>
        /// <param name="actionMode">The action mode of the conversion.</param>
        /// <param name="viewModel">The view model to be populated. Pass a nullable type.</param>
        /// <param name="handled">A boolean value indicating if the conversion has been handled.</param>
        partial void BeforeToViewModel(TAccessModel accessModel, ActionMode actionMode, ref TViewModel? viewModel, ref bool handled);
        /// <summary>
        /// Performs additional operations after converting a view model.
        /// </summary>
        /// <param name="viewModel">The converted view model.</param>
        /// <param name="actionMode">The action mode.</param>
        /// <remarks>
        /// This method is called after the conversion of a view model from a source object.
        /// Any additional operations required on the view model can be performed here.
        /// </remarks>
        partial void AfterToViewModel(TViewModel viewModel, ActionMode actionMode);
        
        /// <summary>
        /// Creates a new instance of the IActionResult class and returns a view with a new instance of the IdentityCreate model from the Account namespace.
        /// </summary>
        /// <returns>A ViewResult object representing the view with the new IdentityCreate model instance.</returns>
        public override IActionResult Create()
        {
            return View(new Models.Account.IdentityCreate());
        }
        /// <summary>
        /// Creates a new identity using the provided model data.
        /// </summary>
        /// <param name="model">The model representing the identity to be created.</param>
        /// <returns>An asynchronous task that represents the operation and returns an IActionResult.</returns>
        /// <remarks>
        /// This method uses HTTP POST and requires anti-forgery token validation.
        /// If the provided model data is valid, it tries to add the new identity to the account access asynchronously.
        /// After successfully adding the identity, it fetches the entity with the same email from the data access asynchronously.
        /// If the entity is found, it redirects to the Edit action with the entity's Id as a parameter.
        /// Otherwise, it redirects to the Index action.
        /// If any exception occurs during the process, the corresponding error message is stored in the ViewBag's Error property.
        /// </remarks>
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> CreateIdentity(Models.Account.IdentityCreate model)
        {
            if (ModelState.IsValid)
            {
                try
                {
                    await Logic.AccountAccess.AddAppAccessAsync(SessionWrapper.SessionToken, model.Name, model.Email, model.Password, model.TimeOutInMinutes, false);
                    
                    var entity = (await DataAccess.QueryAsync($"{nameof(model.Email)}=\"{model.Email}\"")).FirstOrDefault();
                    
                    return entity == null ? RedirectToAction("Index") : RedirectToAction("Edit", new { id=entity.Id });
                }
                catch (Exception ex)
                {
                    ViewBag.Error = ex.Message;
                    
                    if (ex.InnerException != null)
                    {
                        ViewBag.Error = ex.InnerException.Message;
                    }
                }
            }
            else
            {
                ViewBag.Error = string.Join("; ", ModelState.Values
                       .SelectMany(x => x.Errors)
                       .Select(x => x.ErrorMessage));
            }
            return View("Create", model);
        }
        // Extensions
        private Models.Account.IdentityRole[]? accessRoleList;
        /// <summary>
        /// Gets the list of access roles.
        /// </summary>
        /// <remarks>
        /// This property retrieves the access roles from the database, if not already retrieved.
        /// It uses the 'IRolesAccess' interface to fetch the roles.
        /// The roles list is sorted by 'Designation' in ascending order.
        /// </remarks>
        /// <returns>An array of 'IdentityRole' objects representing the access roles.</returns>
        public Models.Account.IdentityRole[] AccessRoleList
        {
            get
            {
                if (accessRoleList == null)
                {
                    var services = HttpContext.RequestServices;
                    using var ctrl = (Logic.Contracts.Account.IRolesAccess)services.GetService(typeof(Logic.Contracts.Account.IRolesAccess))!;
                    
                    ctrl.SessionToken = SessionWrapper.SessionToken;
                    
                    accessRoleList = Task.Run(async () => await ctrl.GetAllAsync("Designation asc")).Result.Select(e => Models.Account.IdentityRole.Create(e)).ToArray();
                }
                return accessRoleList;
            }
        }
        
        /// <summary>
        /// Updates the view model after converting it from the source model.
        /// </summary>
        /// <param name="viewModel">The view model to be updated.</param>
        /// <param name="actionMode">The action mode indicating the type of action being performed.</param>
        partial void AfterToViewModel(TViewModel viewModel, ActionMode actionMode)
        {
            if ((actionMode & ActionMode.EditAction) > 0)
            {
                viewModel.IdentityRoleList = AccessRoleList;
                
            }
        }
        
        /// <summary>
        /// Adds an access role to an instance identified by the provided id.
        /// </summary>
        /// <param name="id">The id of the instance.</param>
        /// <param name="accessRoleId">The id of the access role to be added.</param>
        /// <returns>An <see cref="IActionResult"/> representing the asynchronous operation.</returns>
        public async Task<IActionResult> AddAccessRole(IdType id, IdType accessRoleId)
        {
            try
            {
                if (DataAccess is TAccessContract instanceAccess)
                {
                    await instanceAccess.AddRoleAsync(id, accessRoleId);
                    await instanceAccess.SaveChangesAsync();
                }
            }
            catch (Exception ex)
            {
                ViewBag.Error = ex.Message;
                
                if (ex.InnerException != null)
                {
                    ViewBag.Error = ex.InnerException.Message;
                }
            }
            return RedirectToAction("Edit", new { id });
        }
        /// <summary>
        /// Removes an access role from a specified entity.
        /// </summary>
        /// <param name="id">The ID of the entity.</param>
        /// <param name="accessRoleId">The ID of the access role.</param>
        /// <returns>An asynchronous task that returns an IActionResult.</returns>
        public async Task<IActionResult> RemoveAccessRole(IdType id, IdType accessRoleId)
        {
            try
            {
                if (DataAccess is TAccessContract instanceAccess)
                {
                    await instanceAccess.RemoveRoleAsync(id, accessRoleId);
                    await instanceAccess.SaveChangesAsync();
                }
            }
            catch (Exception ex)
            {
                ViewBag.Error = ex.Message;
                
                if (ex.InnerException != null)
                {
                    ViewBag.Error = ex.InnerException.Message;
                }
            }
            return RedirectToAction("Edit", new { id });
        }
        // Extensions
    }
}
#endif
//MdEnd


