//@BaseCode
//MdStart
using System.Reflection;

namespace TemplateCodeGenerator.Logic.Generation
{
    /// <summary>
    /// Represents a class that contains properties and methods related to item properties.
    /// </summary>
    internal partial class ItemProperties
    {
        /// <summary>
        /// Gets the name of the solution.
        /// </summary>
        /// <value>
        /// A string representing the name of the solution.
        /// </value>
        public string SolutionName { get; }
        /// <summary>
        /// Gets the project file extension.
        /// </summary>
        /// <value>
        /// The project file extension.
        /// </value>
        public string ProjectExtension { get; }
        /// <summary>
        /// Gets the namespace of the project.
        /// </summary>
        /// <value>
        /// The namespace of the project.
        /// </value>
        public string ProjectNamespace => $"{SolutionName}{ProjectExtension}";
        /// Gets the logic project name.
        ///</summary>
        ///<value>
        /// The logic project name generated by concatenating the SolutionName and StaticLiterals.LogicExtension.
        ///</value>
        public string LogicProject => $"{SolutionName}{StaticLiterals.LogicExtension}";
        /// <summary>
        /// Initializes a new instance of the <see cref="ItemProperties"/> class.
        /// </summary>
        /// <param name="solutionName">The name of the solution.</param>
        /// <param name="projectExtension">The extension of the project.</param>
        public ItemProperties(string solutionName, string projectExtension)
        {
            SolutionName = solutionName;
            ProjectExtension = projectExtension;
        }
        
        #region Solution properties
        ///<summary>
        /// Gets or sets the template projects.
        /// The template projects are used as a base for creating new projects.
        ///</summary>
        ///<value>
        /// The array of template projects.
        ///</value>
        public string[] TemplateProjects
        {
            get
            {
                var result = new List<string>(CommonBase.StaticLiterals.TemplateProjects);
                
                foreach (var extension in CommonBase.StaticLiterals.TemplateProjectExtensions)
                {
                    result.Add($"{SolutionName}{extension}");
                }
                result.AddRange(CommonBase.StaticLiterals.TemplateToolProjects);
                return result.ToArray();
            }
        }
        /// <summary>
        /// Gets or sets an array of template project identifiers.
        /// </summary>
        /// <value>
        /// An array of template project identifiers.
        /// </value>
        public static string[] TemplateProjectIdentifiers => CommonBase.StaticLiterals.TemplateProjectExtensions.Select(e => e[1..]).ToArray();
        #endregion Solution properties
        
        #region Item names
        /// <summary>
        /// Generates the entity name from the type.
        /// </summary>
        /// <param name="type">The entity type.</param>
        /// <returns>The entity name.</returns>
        public static string CreateEntityName(Type type) => type.Name;
        /// <summary>
        /// Generates the typescript property name from the property info.
        /// </summary>
        /// <param name="type">The property info object.</param>
        /// <returns>The typescript property name.</returns>
        public static string CreateTSPropertyName(PropertyInfo propertyInfo) => $"{Char.ToLower(propertyInfo.Name[0])}{propertyInfo.Name[1..]}";
        
        /// <summary>
        /// Creates a model name based on the specified type.
        /// </summary>
        /// <param name="type">The type to create the model name for.</param>
        /// <returns>The name of the model.</returns>
        public static string CreateModelName(Type type) => type.Name;
        /// <summary>
        /// Creates the name of the edit model based on the provided type.
        /// </summary>
        /// <param name="type">The type used to create the edit model name.</param>
        /// <returns>The edit model name.</returns>
        public static string CreateEditModelName(Type type)
        {
            return $"{CreateModelName(type)}Edit";
        }
        /// <summary>
        /// Creates a filter model name based on the provided type.
        /// </summary>
        /// <param name="type">The type to create the filter model name for.</param>
        /// <returns>The filter model name as a string.</returns>
        public static string CreateFilterModelName(Type type)
        {
            return $"{CreateModelName(type)}Filter";
        }
        
        /// <summary>
        /// Creates a controller name for the given type.
        /// </summary>
        /// <param name="type">The type used to create the controller name.</param>
        /// <returns>The controller name.</returns>
        public static string CreateControllerName(Type type)
        {
            return $"{type.Name.CreatePluralWord()}";
        }
        /// <summary>
        /// Creates the name of the controller class based on the given type.
        /// </summary>
        /// <param name="type">The type for which the controller class name is to be created.</param>
        /// <returns>The controller class name.</returns>
        public static string CreateControllerClassName(Type type)
        {
            return $"{CreateControllerName(type)}Controller";
        }
        
        /// <summary>
        /// Creates a service name based on the given type.
        /// </summary>
        /// <param name="type">The type to be used for creating the service name.</param>
        /// <returns>The created service name as a string.</returns>
        public static string CreateServiceName(Type type)
        {
            return $"{type.Name.CreatePluralWord()}";
        }
        /// <summary>
        /// This method creates a service class name based on the specified type.
        /// </summary>
        /// <param name="type">The type used to create the service class name.</param>
        /// <returns>
        /// The service class name derived from the specified type and appended with "Service".
        /// </returns>
        public static string CreateServiceClassName(Type type)
        {
            return $"{CreateServiceName(type)}Service";
        }
        
        /// <summary>
        /// Creates the model contract name for a given type.
        /// </summary>
        /// <param name="type">The type for which the model contract name needs to be created.</param>
        /// <returns>The model contract name in the format "I{type.Name}".</returns>
        public static string CreateModelContractName(Type type)
        {
            return $"I{type.Name}";
        }
        /// <summary>
        /// Creates a model navigation contract name for the specified type.
        /// The contract name is prefixed with 'I' and suffixed with 'Navigation'.
        /// </summary>
        /// <param name="type">The type to create the navigation contract name for.</param>
        /// <returns>The model navigation contract name.</returns>
        public static string CreateModelNavigationContractName(Type type)
        {
            return $"I{type.Name}Navigation";
        }
        
        /// <summary>
        /// Creates the name for the access contract based on the provided type.
        /// </summary>
        /// <param name="type">The type to create the access contract name for.</param>
        /// <returns>The access contract name for the specified type.</returns>
        public static string CreateAccessContractName(Type type)
        {
            return $"I{type.Name.CreatePluralWord()}Access";
        }
        /// <summary>
        /// Creates a service contract name based on the provided type.
        /// </summary>
        /// <param name="type">The type for which the service contract name needs to be created.</param>
        /// <returns>The service contract name that starts with 'I' and is pluralized based on the type name.</returns>
        public static string CreateServiceContractName(Type type)
        {
            return $"I{type.Name.CreatePluralWord()}Service";
        }
        
        /// <summary>
        /// Creates the facade class name by appending "Facade" to the pluralized form of the input type name.
        /// </summary>
        /// <param name="type">The input type.</param>
        /// <returns>The facade class name.</returns>
        public static string CreateFacadeClassName(Type type)
        {
            return $"{type.Name.CreatePluralWord()}Facade";
        }
        #endregion Item names
        
        #region Entity items
        /// <summary>
        /// Diese Methode ermittelt den Sub-Typ aus einem Entity-Type (eg. App.Type).
        /// </summary>
        /// <param name="type">Entity-Typ</param>
        /// <returns>Sub-Typ</returns>
        public static string CreateSubTypeFromEntity(Type type)
        {
            var entityName = CreateEntityName(type);
            var namespaceItems = CreateNamespaceItems(type, StaticLiterals.EntitiesFolder).Skip(1);
            
            return $"{string.Join('.', namespaceItems)}.{entityName}";
        }
        
        #endregion Entity items
        
        #region Model items
        /// <summary>
        /// Creates the model type based on the specified type.
        /// </summary>
        /// <param name="type">The type used to create the model type.</param>
        /// <returns>The fully qualified model type in the format 'ProjectNamespace.ModelSubType'.</returns>
        public string CreateModelType(Type type)
        {
            return $"{ProjectNamespace}.{CreateModelSubType(type)}";
        }
        /// <summary>
        /// Creates the model subtype for the specified type.
        /// </summary>
        /// <param name="type">The type to create the subtype for.</param>
        /// <returns>The fully qualified model subtype name.</returns>
        public string CreateModelSubType(Type type)
        {
            var subNamespace = CreateModelSubNamespace(type);
            
            return $"{subNamespace}.{CreateModelName(type)}";
        }
        /// <summary>
        /// Creates the fully-qualified name of the edit model type for the specified <paramref name="type"/>.
        /// </summary>
        /// <param name="type">The type for which to create the edit model type.</param>
        /// <returns>The fully-qualified name of the edit model type.</returns>
        public string CreateEditModelType(Type type)
        {
            return $"{CreateModelNamespace(type)}.{CreateEditModelName(type)}";
        }
        /// <summary>
        /// Creates the fully qualified name of the filter model type.
        /// </summary>
        /// <param name="type">The type of the model.</param>
        /// <returns>The fully qualified name of the filter model type.</returns>
        public string CreateFilterModelType(Type type)
        {
            return $"{CreateModelNamespace(type)}.{CreateFilterModelName(type)}";
        }
        
        /// <summary>
        /// Constructs the namespace for the model based on the given type.
        /// </summary>
        /// <param name="type">The type used to create the model namespace.</param>
        /// <returns>The fully qualified model namespace.</returns>
        public string CreateModelNamespace(Type type)
        {
            return $"{ProjectNamespace}.{CreateModelSubNamespace(type)}";
        }
        /// <summary>
        /// Creates a model sub path based on the provided type, postFix, and fileExtension.
        /// </summary>
        /// <param name="type">The type of the model.</param>
        /// <param name="postFix">The post fix to be appended to the model's name.</param>
        /// <param name="fileExtension">The extension of the file.</param>
        /// <returns>The created model sub path.</returns>
        public string CreateModelSubPath(Type type, string postFix, string fileExtension)
        {
            return Path.Combine(CreateModelSubNamespace(type).Replace(".", Path.DirectorySeparatorChar.ToString()), $"{type.Name}{postFix}{fileExtension}");
        }
        /// <summary>
        /// Converts the full name of an entity type to the full name of a model type.
        /// </summary>
        /// <param name="typeFullname">The full name of the entity type.</param>
        /// <returns>The full name of the corresponding model type.</returns>
        public string ConvertEntityToModelType(string typeFullname)
        {
            var result = typeFullname;
            var entitiesFolder = $".{StaticLiterals.EntitiesFolder}.";
            var modelsFolder = $".{StaticLiterals.ModelsFolder}.";
            
            if (result.Contains(entitiesFolder))
            {
                result = result.Replace(entitiesFolder, modelsFolder);
                result = result.Replace(StaticLiterals.LogicExtension, ProjectExtension);
            }
            return result;
        }
        /// <summary>
        /// This method creates the model sub namespace from a project type.
        /// For example:
        ///     FullName QuickTemplate.Logic.Entities.Base.Artist becomes SubName Models.Base.Artist.
        /// </summary>
        /// <param name="type">The Type from which the subnamespace is created.</param>
        /// <returns>The subnamespace as a string.</returns>
        public string CreateModelSubNamespace(Type type)
        {
            var result = string.Empty;
            
            if (IsModelType(type))
            {
                var namespaceItems = CreateModuleSubNamespaceItems(type, StaticLiterals.ModelsFolder);
                
                result = string.Join('.', namespaceItems);
            }
            else if (IsServiceModelType(type))
            {
                var namespaceItems = CreateModuleSubNamespaceItems(type, StaticLiterals.ServiceModelsFolder);
                
                result = string.Join('.', namespaceItems);
            }
            else if (IsEntityType(type))
            {
                var namespaceItems = CreateModuleSubNamespaceItems(type, StaticLiterals.ModelsFolder);
                
                result = string.Join('.', namespaceItems);
            }
            return result;
        }
        #endregion Model items
        
        #region Logic items
        /// <summary>
        /// Creates a full logic access contract type based on the provided <paramref name="type"/>.
        /// </summary>
        /// <param name="type">The type to be used for creating the full logic access contract type.</param>
        /// <returns>The created full logic access contract type as a string.</returns>
        public string CreateFullLogicAccessContractType(Type type)
        {
            return CreateFullLogicType(type, CreateAccessContractName(type), StaticLiterals.ContractsFolder);
        }
        ///<summary>
        /// Creates the full logic model contract type for the given type.
        ///</summary>
        ///<param name="type">The type for which the full logic model contract type needs to be created.</param>
        ///<returns>The full logic model contract type.</returns>
        public string CreateFullLogicModelContractType(Type type)
        {
            return CreateFullLogicType(type, CreateModelContractName(type), StaticLiterals.ContractsFolder);
        }
        /// <summary>
        /// Creates a full logic model navigation contract type using the specified <paramref name="type"/>.
        /// </summary>
        /// <param name="type">The <see cref="Type"/> of the contract type to create.</param>
        /// <returns>A <see cref="string"/> representing the full logic model navigation contract type.</returns>
        public string CreateFullLogicModelNavigationContractType(Type type)
        {
            return CreateFullLogicType(type, CreateModelNavigationContractName(type), StaticLiterals.ContractsFolder);
        }
        /// <summary>
        /// Creates the full logic model type.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>The full logic model type.</returns>
        public string CreateFullLogicModelType(Type type)
        {
            return CreateFullLogicType(type, CreateModelName(type), StaticLiterals.ModelsFolder);
        }
        /// <summary>
        /// Creates the full logic controller type for the specified <paramref name="type"/>.
        /// </summary>
        /// <param name="type">The type for which to create the full logic controller type.</param>
        /// <returns>The full logic controller type.</returns>
        public string CreateFullLogicControllerType(Type type)
        {
            return CreateFullLogicType(type, CreateControllerClassName(type), StaticLiterals.ControllersFolder);
        }
        /// <summary>
        /// Creates a full logic service type.
        /// </summary>
        /// <param name="type">The type of the service.</param>
        /// <returns>The full logic service type.</returns>
        public string CreateFullLogicServiceType(Type type)
        {
            return CreateFullLogicType(type, CreateServiceClassName(type), StaticLiterals.ServicesFolder);
        }
        /// <summary>
        /// Creates a full service contract type based on the specified <paramref name="type"/>.
        /// </summary>
        /// <param name="type">The type to create the service contract type for.</param>
        /// <returns>The full logic service contract type.</returns>
        public string CreateFullLogicServiceContractType(Type type)
        {
            return CreateFullLogicType(type, CreateServiceContractName(type), StaticLiterals.ContractsFolder);
        }
        /// <summary>
        /// Creates a full logic facade type for the given input <see cref="Type"/>.
        /// </summary>
        /// <param name="type">The input <see cref="Type"/> used to create the full logic facade type.</param>
        /// <returns>The created full logic facade type as a <see cref="string"/>.</returns>
        /// <remarks>
        /// This method internally calls the <see cref="CreateFullLogicType"/> method to create the full logic type,
        /// and then, using the <see cref="CreateFacadeClassName"/> method, generates the facade class name.
        /// The full logic facade type is created in the <see cref="StaticLiterals.FacadesFolder"/> folder.
        /// </remarks>
        public string CreateFullLogicFacadeType(Type type)
        {
            return CreateFullLogicType(type, CreateFacadeClassName(type), StaticLiterals.FacadesFolder);
        }
        /// <summary>
        /// Creates the full logic type by combining the logic namespace, type name, and any optional pre-items.
        /// </summary>
        /// <param name="type">The type of the logic.</param>
        /// <param name="typeName">The name of the type.</param>
        /// <param name="preItems">Optional pre-items to be included in the full logic type.</param>
        /// <returns>The full logic type as a string.</returns>
        public string CreateFullLogicType(Type type, string typeName, params string[] preItems)
        {
            return $"{CreateFullLogicNamespace(type, preItems)}.{typeName}";
        }
        /// <summary>
        /// Creates the full logic namespace for the specified type.
        /// </summary>
        /// <param name="type">The type for which the logic namespace is created.</param>
        /// <param name="preItems">Optional array of pre-defined namespace items.</param>
        /// <returns>The full logic namespace.</returns>
        public string CreateFullLogicNamespace(Type type, params string[] preItems)
        {
            var namespaceItems = CreateModuleSubNamespaceItems(type, preItems);
            
            return $"{LogicProject}.{string.Join('.', namespaceItems)}";
        }
        #endregion logic items
        
        #region SubType items
        /// <summary>
        /// This method creates the part name from a solution type.
        /// For example:
        ///     FullName QuickTemplate.Logic.ServiceModel.Base.Artist becomes SubName ServiceModel.Base.Artist.
        /// </summary>
        /// <param name="type">The Type from which the SubName is created.</param>
        /// <returns>The SubName as a string.</returns>
        public string CreateSubType(Type type)
        {
            return CreateSubType(type.FullName!);
        }
        /// <summary>
        /// This method creates the part name from a solution type.
        /// For example:
        ///     FullName QuickTemplate.Logic.ServiceModel.Base.Artist becomes SubName ServiceModel.Base.Artist.
        /// </summary>
        /// <param name="typeFullName">The Fullname from which the SubName is created.</param>
        /// <returns>The SubName as a string.</returns>
        public string CreateSubType(string typeFullName)
        {
            var ignore = false;
            var result = new List<string>();
            var typeItems = typeFullName.Split('.');
            
            for (int i = 0; i < typeItems?.Length; i++)
            {
                if (typeItems[i].Equals(SolutionName))
                {
                    ignore = true;
                }
                else if (TemplateProjectIdentifiers.Any(e => e.Equals(typeItems[i])))
                {
                    ignore = true;
                }
                else
                {
                    ignore = false;
                }
                if (ignore == false)
                {
                    result.Add(typeItems[i]);
                }
            }
            return string.Join('.', result);
        }
        
        /// <summary>
        /// Creates the access contract sub-type for a given C# type.
        /// </summary>
        /// <param name="type">The C# type for which the access contract sub-type is created.</param>
        /// <returns>The access contract sub-type.</returns>
        public string CreateAccessContractSubType(Type type)
        {
            var namespaceItems = CreateModuleSubNamespaceItems(type, StaticLiterals.ContractsFolder);
            
            return string.Join(".", namespaceItems.Union(new[] { CreateAccessContractName(type) }));
        }
        /// <summary>
        /// Creates a service contract sub-type for the specified <paramref name="type"/>.
        /// </summary>
        /// <param name="type">The type to create the service contract sub-type for.</param>
        /// <returns>A string representation of the service contract sub-type.</returns>
        /// <remarks>
        /// This method creates a service contract sub-type by combining the namespace items created by the <see cref="CreateModuleSubNamespaceItems(Type, string)"/> method
        /// with the <see cref="StaticLiterals.ContractsFolder"/> and the service contract name created by the <see cref="CreateServiceContractName(Type)"/> method.
        /// The resulting sub-type is formed by joining the namespace items with a dot separator and appending the service contract name at the end.
        /// </remarks>
        public string CreateServiceContractSubType(Type type)
        {
            var namespaceItems = CreateModuleSubNamespaceItems(type, StaticLiterals.ContractsFolder);
            
            return string.Join(".", namespaceItems.Union(new[] { CreateServiceContractName(type) }));
        }
        /// <summary>
        /// Creates the facade contract sub type by taking a <paramref name="type"/> as input.
        /// </summary>
        /// <param name="type">The type used to create the facade contract sub type.</param>
        /// <returns>The string representation of the facade contract sub type.</returns>
        public string CreateFacadeContractSubType(Type type)
        {
            var namespaceItems = CreateModuleSubNamespaceItems(type, StaticLiterals.ContractsFolder);
            
            return string.Join(".", namespaceItems.Union(new[] { CreateAccessContractName(type) }));
        }
        #endregion SubType items
        
        #region Contract properties
        /// <summary>
        /// Creates a sub file path.
        /// </summary>
        /// <param name="type">The type used to create the module sub namespace items.</param>
        /// <param name="fileName">The file name to be appended to the sub path.</param>
        /// <param name="preItems">Optional additional items to be included in the sub path.</param>
        /// <returns>The sub file path.</returns>
        public string CreateSubFilePath(Type type, string fileName, params string[] preItems)
        {
            var namespaceItems = CreateModuleSubNamespaceItems(type, preItems);
            
            return $"{string.Join(Path.DirectorySeparatorChar, namespaceItems!.Union(new[] { fileName }))}";
        }
        
        /// <summary>
        /// Creates the XML documentation for the method "CreateClientBlazorContractNamespace".
        /// </summary>
        /// <param name="type">The type of the object.</param>
        /// <returns>The namespace for the client Blazor contract.</returns>
        public string CreateClientBlazorContractNamespace(Type type)
        {
            return $"{SolutionName}{StaticLiterals.ClientBlazorExtension}.{CreateContractSubNamespace(type)}";
        }
        /// <summary>
        /// Generates the service contract sub path using the provided parameters.
        /// </summary>
        /// <param name="type">The Type object representing the contract.</param>
        /// <param name="postFix">A postfix string added to the contract name in the path.</param>
        /// <param name="fileExtension">The file extension appended to the contract name in the path.</param>
        /// <returns>The service contract sub path generated from the Type object and additional parameters.</returns>
        public string CreateServiceContractSubPathFromType(Type type, string postFix, string fileExtension)
        {
            return Path.Combine(CreateContractSubNamespace(type).Replace(".", Path.DirectorySeparatorChar.ToString()), $"{CreateServiceContractName(type)}{postFix}{fileExtension}");
        }
        #endregion Contract properties
        
        #region Controller items
        ///<summary>
        /// Creates the fully qualified name of the controller type.
        ///</summary>
        ///<param name="type">The type of the controller.</param>
        ///<returns>The fully qualified name of the controller type.</returns>
        public string CreateControllerType(Type type)
        {
            return $"{CreateControllerNamespace(type)}.{CreateControllerClassName(type)}";
        }
        /// <summary>
        /// Creates the controller namespace for a given type.
        /// </summary>
        /// <param name="type">The type of the controller.</param>
        /// <returns>The fully qualified controller namespace.</returns>
        public string CreateControllerNamespace(Type type)
        {
            return $"{ProjectNamespace}.{CreateControllerSubNamespace(type)}";
        }
        /// <summary>
        /// Creates the sub-namespace for the controller based on the specified type.
        /// </summary>
        /// <param name="type">The type used to create the sub-namespace.</param>
        /// <returns>The sub-namespace for the controller.</returns>
        public string CreateControllerSubNamespace(Type type)
        {
            var namespaceItems = CreateModuleSubNamespaceItems(type, StaticLiterals.ControllersFolder);
            
            return $"{string.Join('.', namespaceItems)}";
        }
        /// <summary>
        /// Creates the subpath for controllers based on the given type, post-fix, and file extension.
        /// </summary>
        /// <param name="type">The type to create the subpath from.</param>
        /// <param name="postFix">The post-fix to append to the subpath.</param>
        /// <param name="fileExtension">The file extension to include in the subpath.</param>
        /// <returns>The created subpath for controllers.</returns>
        public string CreateControllersSubPathFromType(Type type, string postFix, string fileExtension)
        {
            return Path.Combine(CreateControllerSubNamespace(type).Replace(".", Path.DirectorySeparatorChar.ToString()), $"{CreateControllerClassName(type)}{postFix}{fileExtension}");
        }
        #endregion Controller items
        
        #region Service items
        /// <summary>
        /// Creates the service type based on the given Type object.
        /// </summary>
        /// <param name="type">The Type object representing the service.</param>
        /// <returns>The fully qualified name of the service type.</returns>
        public string CreateServiceType(Type type)
        {
            return $"{CreateServiceNamespace(type)}.{CreateServiceClassName(type)}";
        }
        /// <summary>
        /// Creates the service subtype by concatenating the service subnamespace and service class name.
        /// </summary>
        /// <param name="type">The type of the service.</param>
        /// <returns>The fully qualified service subtype.</returns>
        public string CreateServiceSubType(Type type)
        {
            return $"{CreateServiceSubNamespace(type)}.{CreateServiceClassName(type)}";
        }
        /// <summary>
        /// Creates a service namespace based on the provided type.
        /// </summary>
        /// <param name="type">The type to create the service namespace for.</param>
        /// <returns>The created service namespace.</returns>
        public string CreateServiceNamespace(Type type)
        {
            return $"{ProjectNamespace}.{CreateServiceSubNamespace(type)}";
        }
        /// <summary>
        /// Creates a service sub-namespace for the specified type.
        /// </summary>
        /// <param name="type">The type used to create the sub-namespace.</param>
        /// <returns>A string representing the service sub-namespace.</returns>
        public string CreateServiceSubNamespace(Type type)
        {
            var namespaceItems = CreateModuleSubNamespaceItems(type, StaticLiterals.ServicesFolder);
            
            return $"{string.Join('.', namespaceItems)}";
        }
        /// <summary>
        /// Creates a services sub path from a given <paramref name="type"/>, <paramref name="postFix"/>, and <paramref name="fileExtension"/>.
        /// </summary>
        /// <param name="type">The type to create the services sub path from.</param>
        /// <param name="postFix">The postfix to append to the service class name.</param>
        /// <param name="fileExtension">The file extension to append to the service class name.</param>
        /// <returns>The services sub path created from the type, postfix, and file extension.</returns>
        public string CreateServicesSubPathFromType(Type type, string postFix, string fileExtension)
        {
            return Path.Combine(CreateServiceSubNamespace(type).Replace(".", Path.DirectorySeparatorChar.ToString()), $"{CreateServiceClassName(type)}{postFix}{fileExtension}");
        }
        #endregion Service items
        
        #region View properties
        /// <summary>
        /// Creates a view subpath from a given Type, fileName, and fileExtension.
        /// </summary>
        /// <param name="type">The Type used to create the subpath.</param>
        /// <param name="fileName">The name of the file.</param>
        /// <param name="fileExtension">The extension of the file.</param>
        /// <returns>The view subpath combing the ViewsFolder, plural form of the Type's name, fileName, and fileExtension.</returns>
        public static string CreateViewSubPathFromType(Type type, string fileName, string fileExtension)
        {
            return Path.Combine(StaticLiterals.ViewsFolder, $"{type.Name.CreatePluralWord()}", $"{fileName}{fileExtension}");
        }
        #endregion View properties
        
        /// <summary>
        /// Diese Methode ermittelt den Teilnamensraum von einem Typ.
        /// </summary>
        /// <param name="type">Typ von welchem der Teilnamensraum ermittelt wird.</param>
        /// <returns>Teil-Namensraum</returns>
        public static string CreateSubNamespaceFromType(Type type)
        {
            var namespaceItems = type.Namespace?.Split('.').Skip(2);
            
            return string.Join('.', namespaceItems!);
        }
        
        /// <summary>
        /// This method creates the sub namespace from a solution entity type.
        /// For example:
        ///     FullName QuickTemplate.Logic.Entities.Base.Artist becomes SubName Contracts.Base.Artist.
        /// </summary>
        /// <param name="type">The Type from which the subnamespace is created.</param>
        /// <returns>The subnamespace as a string.</returns>
        public string CreateContractSubNamespace(Type type)
        {
            var namespaceItems = CreateModuleSubNamespaceItems(type, StaticLiterals.ContractsFolder);
            
            return string.Join('.', namespaceItems);
        }
        
        /// <summary>
        /// Diese Methode ermittelt den Teil-Path aus einem Typ.
        /// </summary>
        /// <param name="type">Typ</param>
        /// <returns>Teil-Path</returns>
        public static string CreateSubPathFromType(Type type)
        {
            var namespaceItems = type.Namespace?.Split('.').Skip(2);
            
            return string.Join(Path.DirectorySeparatorChar, namespaceItems!);
        }
        
        /// <summary>
        /// Erzeugt die Elemente eines Namensraums ab einem bestimmten Element.
        /// </summary>
        /// <param name="type">Typ aus dem die Elemente erzeugt werden.</param>
        /// <param name="catcheItem">Ab welchem Element die Elemente aufgesammelt werden.</param>
        /// <returns></returns>
        public static IEnumerable<string> CreateNamespaceItems(Type type, string catcheItem)
        {
            var catched = false;
            var result = new List<string>();
            var namespaceItems = type.Namespace?.Split('.');
            
            for (int i = 0; i < namespaceItems?.Length; i++)
            {
                if (namespaceItems[i].Equals(catcheItem))
                {
                    catched = true;
                }
                if (catched)
                {
                    result.Add(namespaceItems[i]);
                }
            }
            return catched ? result : namespaceItems!;
        }
        /// <summary>
        /// Erzeugt die Elemente des Subnamensraums ohne Modul (Z.B.: Type: QuickTemplate.Logic.Entities.Base.Company -> Base).
        /// </summary>
        /// <param name="type">Typ aus dem die Elemente erzeugt werden.</param>
        /// <returns></returns>
        public IEnumerable<string> CreateModuleSubNamespaceItems(Type type, params string[] preItems)
        {
            var ignore = false;
            var result = new List<string>();
            var namespaceItems = type.Namespace?.Split('.');
            
            for (int i = 0; i < namespaceItems?.Length; i++)
            {
                if (namespaceItems[i].Equals(SolutionName))
                {
                    ignore = true;
                }
                else if (TemplateProjectIdentifiers.Any(e => e.Equals(namespaceItems[i])))
                {
                    ignore = true;
                }
                else if (StaticLiterals.ModuleFolders.Any(e => e.Equals(namespaceItems[i])))
                {
                    ignore = true;
                }
                else
                {
                    ignore = false;
                }
                if (ignore == false)
                {
                    result.Add(namespaceItems[i]);
                }
            }
            return preItems.Union(result);
        }
        
        #region Type infos
        /// <summary>
        /// Determines whether the specified type is an array type.
        /// </summary>
        /// <param name="type">The type to check.</param>
        /// <returns>
        ///   <c>true</c> if the specified type is an array; otherwise, <c>false</c>.
        /// </returns>
        /// /
        public static bool IsArrayType(Type type)
        {
            return type.IsArray;
        }
        /// <summary>
        /// Determines whether the specified type is a list type.
        /// </summary>
        /// <param name="type">The type to check.</param>
        /// <returns>true if the type is a list type; otherwise, false.</returns>
        public static bool IsListType(Type type)
        {
            return type.FullName!.StartsWith("System.Collections.Generic.List")
            || type.FullName!.StartsWith("System.Collections.Generic.IList");
        }
        /// <summary>
        /// Determines whether the given type is an entity type.
        /// </summary>
        /// <param name="type">The type to check.</param>
        /// <returns>
        /// <c>true</c> if the given type is an entity type; otherwise, <c>false</c>.
        /// </returns>
        public static bool IsEntityType(Type type)
        {
            return type.GetBaseTypes().FirstOrDefault(t => t.Name.Equals(StaticLiterals.EntityObjectName)) != null;
        }
        /// <summary>
        /// Checks if the specified type is a List type containing entities.
        /// </summary>
        /// <param name="type">The type to be checked.</param>
        /// <returns>True if the type is a List type containing entities, otherwise false.</returns>
        public static bool IsEntityListType(Type type)
        {
            var result = false;
            
            if (type.IsGenericType && IsListType(type))
            {
                var genericType = type.GetGenericArguments()[0];
                
                result = IsEntityType(genericType);
            }
            return result;
        }
        /// <summary>
        /// Determines whether the specified Type is a model type.
        /// </summary>
        /// <param name="type">The Type to be checked.</param>
        /// <returns>True if the specified Type is a model type; otherwise, False.</returns>
        public static bool IsModelType(Type type)
        {
            return type.GetBaseTypes().FirstOrDefault(t => t.Name.Equals(StaticLiterals.ModelObjectName)) != null;
        }
        /// <summary>
        /// Determines if the given type is a model list type.
        /// </summary>
        /// <param name="type">The type to check.</param>
        /// <returns>True if the given type is a model list type, false otherwise.</returns>
        public static bool IsModelListType(Type type)
        {
            var result = false;
            
            if (type.IsGenericType && IsListType(type))
            {
                var genericType = type.GetGenericArguments()[0];
                
                result = IsModelType(genericType);
            }
            return result;
        }
        /// <summary>
        /// Determines if a given string represents a model type.
        /// </summary>
        /// <param name="strType">The string type to be checked.</param>
        /// <returns>True if the string type contains the specified ModelsFolder; otherwise, false.</returns>
        public static bool IsModelType(string strType)
        {
            return strType.Contains($".{StaticLiterals.ModelsFolder}.");
        }
        /// <summary>
        /// Determines if the specified type is a service model type.
        /// </summary>
        /// <param name="type">The type to check.</param>
        /// <returns>true if the specified type is a service model type; otherwise, false.</returns>
        public static bool IsServiceModelType(Type type)
        {
            return type.GetBaseTypes().FirstOrDefault(t => t.Name.Equals(StaticLiterals.ServiceModelName)) != null;
        }
        /// <summary>
        /// Determines whether the given string represents a Service Model type.
        /// </summary>
        /// <param name="strType">The string to check.</param>
        /// <returns><c>true</c> if the string represents a Service Model type; otherwise, <c>false</c>.</returns>
        public static bool IsServiceModelType(string strType)
        {
            return strType.Contains($".{StaticLiterals.ServiceModelsFolder}.");
        }
        #endregion Type infos
    }
}
//MdEnd


